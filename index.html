
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com\0xor1\joak\joak.go (69.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package joak

import(
        `time`
        `sync`
        `errors`
        `github.com/0xor1/oak`
        `github.com/0xor1/sus`
        `github.com/0xor1/sid`
        `github.com/qedus/nds`
        `github.com/gorilla/mux`
        `golang.org/x/net/context`
        `github.com/gorilla/sessions`
        "google.golang.org/appengine/datastore"
)

type Entity interface{
        sus.Version
        IsActive() bool
        CreatedBy() (userId string)
        RegisterNewUser() (userId string, err error)
        UnregisterUser(userId string) error
        Kick() (updated bool)
}

type EntityFactory func()Entity

func now() time.Time <span class="cov8" title="1">{
        return time.Now().UTC()
}</span>

type gaeStoreObj struct{
        Entity                                         `datastore:",noindex"`
        DeleteAfter time.Time        `datastore:""`
}

func newGaeStore(kind string, ef EntityFactory, deleteAfterDur time.Duration, clearOutDur time.Duration) (oak.EntityStore, error) <span class="cov8" title="1">{
        if kind == `` </span><span class="cov8" title="1">{
                return nil, errors.New(`kind must not be an empty string`)
        }</span>
        <span class="cov8" title="1">if deleteAfterDur.Seconds() &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New(`deleteAfterDur must be a positive time.Duration`)
        }</span>
        <span class="cov8" title="1">if clearOutDur.Seconds() &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New(`clearOutDur must be a positive time.Duration`)
        }</span>

        <span class="cov8" title="1">var lastGaeClearOut time.Time
        var mtx sync.Mutex

        pre := func() </span><span class="cov0" title="0">{
                myLastGaeClearOutInst := lastGaeClearOut
                if lastGaeClearOut.IsZero() || time.Since(lastGaeClearOut) &gt;= clearOutDur </span><span class="cov0" title="0">{
                        mtx.Lock()
                        if lastGaeClearOut != myLastGaeClearOutInst </span><span class="cov0" title="0">{
                                mtx.Unlock()
                                return
                        }</span>
                        <span class="cov0" title="0">lastGaeClearOut = now()
                        mtx.Unlock()
                        q := datastore.NewQuery(kind).Filter(`DeleteAfter &lt;=`, now()).KeysOnly()
                        keys := []*datastore.Key{}
                        for iter := q.Run(context.Background()); ; </span><span class="cov0" title="0">{
                                key, err := iter.Next(nil)
                                if err == datastore.Done </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">keys = append(keys, key)</span>
                        }
                        <span class="cov0" title="0">nds.DeleteMulti(context.Background(), keys)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">return &amp;entityStore{isForGae: true, deleteAfter: deleteAfterDur, preprocess: pre, inner: sus.NewGaeStore(kind, sid.Uuid, func()sus.Version</span><span class="cov0" title="0">{return &amp;gaeStoreObj{Entity: ef(), DeleteAfter: now().Add(deleteAfterDur)}}</span>)}, nil
}

func newMemoryStore(ef EntityFactory) oak.EntityStore <span class="cov8" title="1">{
        pre := func()</span><span class="cov8" title="1">{}</span>
        <span class="cov8" title="1">return &amp;entityStore{isForGae: false, preprocess: pre, inner: sus.NewJsonMemoryStore(sid.Uuid, func()sus.Version</span><span class="cov8" title="1">{return ef()}</span>)}
}

type entityStore struct {
        isForGae        bool
        deleteAfter        time.Duration
        preprocess  func()
        inner                 sus.Store
}

func (es *entityStore) Create() (string, oak.Entity, error) <span class="cov8" title="1">{
        go es.preprocess()
        id, v, err := es.inner.Create()
        var e Entity
        if err == nil &amp;&amp; v != nil </span><span class="cov8" title="1">{
                e = v.(Entity)
        }</span>
        <span class="cov8" title="1">return id, e, err</span>
}

func (es *entityStore) Read(entityId string) (oak.Entity, error) <span class="cov8" title="1">{
        go es.preprocess()
        v, err := es.inner.Read(entityId)
        var e Entity
        if err == nil &amp;&amp; v != nil </span><span class="cov8" title="1">{
                e = v.(Entity)
        }</span>
        <span class="cov8" title="1">return e, err</span>
}

func (es *entityStore) Update(entityId string, entity oak.Entity) (error) <span class="cov8" title="1">{
        go es.preprocess()
        if es.isForGae &amp;&amp; es.deleteAfter.Seconds() &gt; 0</span><span class="cov8" title="1">{
                gso, ok := entity.(*gaeStoreObj)
                if ok </span><span class="cov8" title="1">{
                        gso.DeleteAfter = now().Add(es.deleteAfter)
                }</span>
        }
        <span class="cov8" title="1">e, _ := entity.(Entity)
        return es.inner.Update(entityId, e)</span>
}

func RouteLocalTest(router *mux.Router, ef EntityFactory, sessionMaxAge int, sessionName string, entity Entity, getJoinResp oak.GetJoinResp, getEntityChangeResp oak.GetEntityChangeResp, performAct oak.PerformAct)<span class="cov8" title="1">{
        ss := sessions.NewCookieStore()
        ss.Options.HttpOnly = false
        ss.Options.MaxAge = sessionMaxAge
        oak.Route(router, ss, sessionName, entity, newMemoryStore(ef), getJoinResp, getEntityChangeResp, performAct)
}</span>

func RouteGaeProd(router *mux.Router, ef EntityFactory, sessionMaxAge int, sessionName string, entity Entity, getJoinResp oak.GetJoinResp, getEntityChangeResp oak.GetEntityChangeResp, performAct oak.PerformAct, kind string, deleteAfterDuration time.Duration, clearOutDur time.Duration, newAuthKey string, newCryptKey string, oldAuthKey string, oldCryptKey string) error <span class="cov8" title="1">{
        ss := sessions.NewCookieStore([]byte(newAuthKey), []byte(newCryptKey), []byte(oldAuthKey), []byte(oldCryptKey))
        ss.Options.HttpOnly = true
        ss.Options.MaxAge = sessionMaxAge
        es, err := newGaeStore(kind, ef, deleteAfterDuration, clearOutDur)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">oak.Route(router, ss, sessionName, entity, es, getJoinResp, getEntityChangeResp, performAct)
        return nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
